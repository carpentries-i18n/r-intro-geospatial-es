---
# Please do not edit this file directly; it is auto generated.
# Instead, please edit 03-data-structures-part1.md in _episodes_rmd/
title: "Estructura de datos"
teaching: 40
exercises: 15
questions:
- "¿Cómo puedo leer datos en R?"
- "¿Cuáles son los tipos de datos básicos en R?"
- "¿Cómo puedo representar información categórica en R?"
objectives:
- "Conocer los distintos tipos de datos."
- "Iniciar a explorar data frames y entender como están relacionados con vectores, factores y listas."
- "Ser capaz de preguntar a R sobre el tipo, la clase y la estructura de un objeto."
keypoints:
- "Usar `read.csv` para leer datos tabulados desde R."
- "Los tipos de datos fundamentales en R son dobles, enteros, complejos, lógicos y carácter."
- "Usar factores para representar categorías en R."
source: Rmd
---



Uno de las características más poderosas de R es su capacidad de manejar datos tabulados - 
como los que tal vez ya tengas en una hoja de cálculo o un archivo CSV.
Empecemos por
descargar y leer en R el archivo `nordic-data.csv`. Cargaremos estos datos como un objeto llamado `nordic`:


~~~
nordic <- read.csv("data/nordic-data.csv")
~~~
{: .language-r}

La función `read.table` se usa para leer datos tabulados guardados en un fichero de
texto donde las columnas de los datos están separadas por
caracteres de puntuación como sucede en
los archivos CSV (csv = valores separados por comas). Tabuladores y comas son los caracteres más usados para separar o delimitar datos en archivos csv.
Por comodidad R provee dos otras versiones de `read.table`. Esas son: `read.csv`
para archivos donde los datos están separados por comas y
`read.delim` para archivos con datos separados por tabuladores. De esas tres funciones `read.csv` es la más usada. Si es necesario, es posible cambiar las el carácter por defecto usado para delimitar tanto en `read.csv` y `read.delim`.

Podemos empezar explorando nuestro conjunto de datos extrayendo columnas especificándolas
usando el operador `$`:


~~~
nordic$country
~~~
{: .language-r}



~~~
[1] "Denmark" "Sweden"  "Norway" 
~~~
{: .output}



~~~
nordic$lifeExp
~~~
{: .language-r}



~~~
[1] 77.2 80.0 79.0
~~~
{: .output}

Podemos hacer otras operaciones a las columnas. Por ejemplo, si descubrimos que la esperanza de vida es dos años más alta:


~~~
nordic$lifeExp + 2
~~~
{: .language-r}



~~~
[1] 79.2 82.0 81.0
~~~
{: .output}

Pero qué si hacemos:


~~~
nordic$lifeExp + nordic$country
~~~
{: .language-r}



~~~
Error in nordic$lifeExp + nordic$country: non-numeric argument to binary operator
~~~
{: .error}

Understanding what happened here is key to successfully analyzing data in R.

## Tipo de datos

Si pensaste que el último comando resultaría en un error porque  `77.2` más `"Denmark"` no tiene sentido, entonces acertaste - y ya tienes una intuición para un
concepto importante en programación llamado *clases de datos*. Podemos preguntar a R qué clase de datos es algo:


~~~
class(nordic$lifeExp)
~~~
{: .language-r}



~~~
[1] "numeric"
~~~
{: .output}

Hay 6 tipos de datos fundamentales: `numeric`, `integer`, `complex`, `logical`, `character`, y `factor`.


~~~
class(3.14)
~~~
{: .language-r}



~~~
[1] "numeric"
~~~
{: .output}



~~~
class(1L) # El sufijo L fuerza que el número sea un entero ya que R los guarda como punto flotante por defecto
~~~
{: .language-r}



~~~
[1] "integer"
~~~
{: .output}



~~~
class(1+1i)
~~~
{: .language-r}



~~~
[1] "complex"
~~~
{: .output}



~~~
class(TRUE)
~~~
{: .language-r}



~~~
[1] "logical"
~~~
{: .output}



~~~
class('banana')
~~~
{: .language-r}



~~~
[1] "character"
~~~
{: .output}



~~~
class(factor('banana'))
~~~
{: .language-r}



~~~
[1] "factor"
~~~
{: .output}

No importa cuan complicado sea nuestro análisis, todos los datos en R se convierten a una 
clase de datos específica. Esta rigurosidad tiene algunas consecuencias realmente importantes.

Un usuario ha añadido nuevos detalles a la esperanza de vida. Dicha información está en el archivo
`data/nordic-data-2.csv`.

Carga los datos nuevos como `nordic_2` y comprubeba  de que clase es la columna
`lifeExp`:


~~~
nordic_2 <- read.csv("data/nordic-data-2.csv")
class(nordic_2$lifeExp)
~~~
{: .language-r}



~~~
[1] "character"
~~~
{: .output}

¡Oh no, nuestra esperanza de vida lifeExp ya no es de tipo numérico! Si intentamos realizar las mismas operaciones
que hicimos en la columna como hicimos antes, nos encontraremos con problemas:


~~~
nordic_2$lifeExp + 2
~~~
{: .language-r}



~~~
Error in nordic_2$lifeExp + 2: non-numeric argument to binary operator
~~~
{: .error}

¿Qué ha sucedido? Cuando R lee un archivo csv en una de esas tablas, R insiste que
todo en una columna sea de la misma clase. Si R no puede entender
*todo* en una columna como numérico, entonces a *nada* en la columna se le asigna el tipo numérico. La tabla en la que R cargó nuestros datos nórdicos es algo conocido como marco de datos, y es nuestro primer ejemplo de lo que se conoce como una *estructura de datos* - es decir, una estructura que R sabe como construir partiendo de tipo de datos fundamentales.

Podemos ver que us un marco de datos (**dataframe**) llamándo la función `class()` en ella:


~~~
class(nordic)
~~~
{: .language-r}



~~~
[1] "data.frame"
~~~
{: .output}

Para usar con éxito nuestros datos en R, necesitamos entender cuales son las estructuras de datos fundamentales
y como se comportan.

## Vectors and Type Coercion

To better understand this behavior, let's meet another of the data structures:
the vector.


~~~
my_vector <- vector(length = 3)
my_vector
~~~
{: .language-r}



~~~
[1] FALSE FALSE FALSE
~~~
{: .output}

A vector in R is essentially an ordered list of things, with the special
condition that everything in the vector must be the same basic data type. If
you don't choose the data type, it'll default to `logical`; or, you can declare
an empty vector of whatever type you like.


~~~
another_vector <- vector(mode = 'character', length = 3)
another_vector
~~~
{: .language-r}



~~~
[1] "" "" ""
~~~
{: .output}

You can check if something is a vector:


~~~
str(another_vector)
~~~
{: .language-r}



~~~
 chr [1:3] "" "" ""
~~~
{: .output}

The somewhat cryptic output from this command indicates the basic data type
found in this vector - in this case `chr`, character; an indication of the
number of things in the vector - actually, the indexes of the vector, in this
case `[1:3]`; and a few examples of what's actually in the vector - in this case
empty character strings. If we similarly do


~~~
str(nordic$lifeExp)
~~~
{: .language-r}



~~~
 num [1:3] 77.2 80 79
~~~
{: .output}

we see that `nordic$lifeExp` is a vector, too - the columns of data we load into R
data frames are all vectors, and that's the root of why R forces everything in
a column to be the same basic data type.

> ## Discussion 1
>
> Why is R so opinionated about what we put in our columns of data?
> How does this help us?
>
> > ## Discussion 1
> >
> > By keeping everything in a column the same, we allow ourselves to make simple
> > assumptions about our data; if you can interpret one entry in the column as a
> > number, then you can interpret *all* of them as numbers, so we don't have to
> > check every time. This consistency is what people mean when they talk about
> > *clean data*; in the long run, strict consistency goes a long way to making
> > our lives easier in R.
> {: .solution}
{: .discussion}

You can also make vectors with explicit contents with the combine function:


~~~
combine_vector <- c(2, 6, 3)
combine_vector
~~~
{: .language-r}



~~~
[1] 2 6 3
~~~
{: .output}

Given what we've learned so far, what do you think the following will produce?


~~~
quiz_vector <- c(2, 6, '3')
~~~
{: .language-r}

This is something called *type coercion*, and it is the source of many surprises
and the reason why we need to be aware of the basic data types and how R will
interpret them. When R encounters a mix of types (here numeric and character) to
be combined into a single vector, it will force them all to be the same
type. Consider:


~~~
coercion_vector <- c('a', TRUE)
coercion_vector
~~~
{: .language-r}



~~~
[1] "a"    "TRUE"
~~~
{: .output}



~~~
another_coercion_vector <- c(0, TRUE)
another_coercion_vector
~~~
{: .language-r}



~~~
[1] 0 1
~~~
{: .output}

The coercion rules go: `logical` -> `integer` -> `numeric` -> `complex` ->
`character`, where -> can be read as *are transformed into*. You can try to
force coercion against this flow using the `as.` functions:


~~~
character_vector_example <- c('0', '2', '4')
character_vector_example
~~~
{: .language-r}



~~~
[1] "0" "2" "4"
~~~
{: .output}



~~~
character_coerced_to_numeric <- as.numeric(character_vector_example)
character_coerced_to_numeric
~~~
{: .language-r}



~~~
[1] 0 2 4
~~~
{: .output}



~~~
numeric_coerced_to_logical <- as.logical(character_coerced_to_numeric)
numeric_coerced_to_logical
~~~
{: .language-r}



~~~
[1] FALSE  TRUE  TRUE
~~~
{: .output}

As you can see, some surprising things can happen when R forces one basic data
type into another! Nitty-gritty of type coercion aside, the point is: if your
data doesn't look like what you thought it was going to look like, type coercion
may well be to blame; make sure everything is the same type in your vectors and
your columns of data frames, or you will get nasty surprises!

> ## Challenge 1
> 
> Given what you now know about type conversion, look at the class of
> data in `nordic_2$lifeExp` and compare it with `nordic$lifeExp`. Why are
> these columns different classes? 
> 
> > ## Solution
> > 
> > ~~~
> > str(nordic_2$lifeExp)
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> >  chr [1:3] "77.2" "80" "79.0 or 83"
> > ~~~
> > {: .output}
> > 
> > 
> > 
> > ~~~
> > str(nordic$lifeExp)
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> >  num [1:3] 77.2 80 79
> > ~~~
> > {: .output}
> > The data in `nordic_2$lifeExp` is stored as factors rather than 
> > numeric. This is because of the "or" character string in the third 
> > data point. "Factor" is R's special term for categorical data. 
> > We will be working more with factor data later in this workshop.
> {: .solution}
{: .challenge}

The combine function, `c()`, will also append things to an existing vector:


~~~
ab_vector <- c('a', 'b')
ab_vector
~~~
{: .language-r}



~~~
[1] "a" "b"
~~~
{: .output}



~~~
combine_example <- c(ab_vector, 'DC')
combine_example
~~~
{: .language-r}



~~~
[1] "a"  "b"  "DC"
~~~
{: .output}

You can also make series of numbers:


~~~
my_series <- 1:10
my_series
~~~
{: .language-r}



~~~
 [1]  1  2  3  4  5  6  7  8  9 10
~~~
{: .output}



~~~
seq(10)
~~~
{: .language-r}



~~~
 [1]  1  2  3  4  5  6  7  8  9 10
~~~
{: .output}



~~~
seq(1,10, by = 0.1)
~~~
{: .language-r}



~~~
 [1]  1.0  1.1  1.2  1.3  1.4  1.5  1.6  1.7  1.8  1.9  2.0  2.1  2.2  2.3  2.4
[16]  2.5  2.6  2.7  2.8  2.9  3.0  3.1  3.2  3.3  3.4  3.5  3.6  3.7  3.8  3.9
[31]  4.0  4.1  4.2  4.3  4.4  4.5  4.6  4.7  4.8  4.9  5.0  5.1  5.2  5.3  5.4
[46]  5.5  5.6  5.7  5.8  5.9  6.0  6.1  6.2  6.3  6.4  6.5  6.6  6.7  6.8  6.9
[61]  7.0  7.1  7.2  7.3  7.4  7.5  7.6  7.7  7.8  7.9  8.0  8.1  8.2  8.3  8.4
[76]  8.5  8.6  8.7  8.8  8.9  9.0  9.1  9.2  9.3  9.4  9.5  9.6  9.7  9.8  9.9
[91] 10.0
~~~
{: .output}

We can ask a few questions about vectors:


~~~
sequence_example <- seq(10)
head(sequence_example,n = 2)
~~~
{: .language-r}



~~~
[1] 1 2
~~~
{: .output}



~~~
tail(sequence_example, n = 4)
~~~
{: .language-r}



~~~
[1]  7  8  9 10
~~~
{: .output}



~~~
length(sequence_example)
~~~
{: .language-r}



~~~
[1] 10
~~~
{: .output}



~~~
class(sequence_example)
~~~
{: .language-r}



~~~
[1] "integer"
~~~
{: .output}

Finalmente, puedes poner nombres a los elementos en tu vector: 


~~~
my_example <- 5:8
names(my_example) <- c("a", "b", "c", "d")
my_example
~~~
{: .language-r}



~~~
a b c d 
5 6 7 8 
~~~
{: .output}



~~~
names(my_example)
~~~
{: .language-r}



~~~
[1] "a" "b" "c" "d"
~~~
{: .output}

> ## Challenge 2
>
>Empieza por hacer un vector con los números 1 a 26. 
>Multiplica el vector por 2, y da al vector resultante los 
>nombres A a Z (sugerencia: hay un vector incorporado llamado `LETTERS`)
>
>>##Solución al Desafío 2 
>>
>>
>>~~~
>><- 1:26
> > x <- x * 2
> > names(x) <- LETTERS
>> ~~~
> > {: .language-r}
> {: .solution}
{: .challenge}


## Factores

Dijimos que las columnas en los **dataframes** eran vectores: 


~~~
str(nordic$lifeExp)
~~~
{: .language-r}



~~~
 num [1:3] 77.2 80 79
~~~
{: .output}



~~~
str(nordic$year)
~~~
{: .language-r}



~~~
int [1:3] 2002 2002 2002
~~~
{: .output}

Esto tiene sentido. Pero qué pasa con


~~~
str(nordic$country)
~~~
{: .language-r}



~~~
chr [1:3] "Denmark" "Sweden" "Norway"
~~~
{: .output}

Otra estructura de datos importante se llama factor. 
Los factores se parecen a los datos de tipo carácter, pero se usan para representar información categórica. 
Por ejemplo, hagamos un vector de tipo **string** etiquetando los países nórdicos para todos los países de nuestro estudio. 


~~~
nordic_countries <- c('Norway', 'Finland', 'Denmark', 'Iceland', 'Sweden')
nordic_countries
~~~
{: .language-r}



~~~
[1] "Norway"  "Finland" "Denmark" "Iceland" "Sweden" 
~~~
{: .output}



~~~
str(nordic_countries)
~~~
{: .language-r}



~~~
 chr [1:5] "Norway" "Finland" "Denmark" "Iceland" "Sweden"
~~~
{: .output}

Podemos convertir un vector en un factor así: 


~~~
categories <- factor(nordic_countries)
class(categories)
~~~
{: .language-r}



~~~
[1] "factor"
~~~
{: .output}



~~~
str(categories)
~~~
{: .language-r}



~~~
 Factor w/ 5 levels "Denmark","Finland",..: 4 2 1 3 5
~~~
{: .output}

Ahora R identificó que hay 5 categorías posibles en nuestra data - pero también realizó algo sorprendente; 
en vez de mostrar la secuencia de caracteres que le dimos, tenemos un montón de números en su lugar. 
R remplazó nuestras categorías legibles para humanos con índices numerados por detrás, 
esto es necesario ya que muchos cálculos estadísticos utilizan esta representación numérica para datos categóricos. 


~~~
class(nordic_countries)
~~~
{: .language-r}



~~~
[1] "character"
~~~
{: .output}



~~~
class(categories)
~~~
{: .language-r}



~~~
[1] "factor"
~~~
{: .output}

> ## Desafío
>
> ¿Puedes adivinar por qué estos números son utilizados para representar a estos países?
>
>> ## Solución
>> 
>> Están ordenados alfabéticamente. 
> {: .solution}
{: .challenge}

> ## Challenge 3
>
> ¿Hay un factor en nuestro **dataframe** `nordic`? Trata de usar
> `?read.csv` para deducir como mantener las columnas de texto como vectores de caracteres
> en vez de factores; luego escribe un comando o dos para mostrar que el factor en
> `nordic` es en realidad un vector de caracteres cuando está cargado de esta manera .
>
> > ## Solución al Desafío 3
> >
> > Una solución es usar el argumento `stringAsFactors`:
> >
> > 
> > ~~~
> > nordic <- read.csv(file = "data/nordic-data.csv", stringsAsFactors = FALSE)
> > str(nordic$country)
> > ~~~
> > {: .language-r}
> >
> > Otra solución es usar el argumento `colClasses`
> > que permite un control más fino.
> >
> > 
> > ~~~
> > nordic <- read.csv(file="data/nordic-data.csv", colClasses=c(NA, NA, "character"))
> > str(nordic$country)
> > ~~~
> > {: .language-r}
> >
> > Nota: nuevos estudiantes encuentran difícil de entender los archivos de ayuda ; asegúrate de hacerles saber
> > que es común, y de alentarlos a hacer su mejor conjetura sobre el significado semántico,
> > incluso si no están seguros.
> {: .solution}
{: .challenge}

Al hacer modelos estadísticos, es importante conocer cuales son los **levels** (categorías) de base. 
Se supone que este es el primer factor, pero por defecto los factores
se etiquetan alfabéticamente. Puedes cambiar esto al especificar los **levels** (categorías):


~~~
mydata <- c("case", "control", "control", "case")
factor_ordering_example <- factor(mydata, levels = c("control", "case"))
str(factor_ordering_example)
~~~
{: .language-r}



~~~
 Factor w/ 2 levels "control","case": 2 1 1 2
~~~
{: .output}

En este caso, le dijimos a R que "control" debería ser representado con 1, 
y "case" con 2. ¡Esta designación puede ser muy importante para interpretar los 
resultados de modelos estadísticos!

## Listas

Otra estructura de datos que querrás tener en tu bolsa de trucos es la `lista`. 
Una lista es en de algún modo más simple que otros tipos, porque
puedes poner lo quieras dentro: 


~~~
list_example <- list(1, "a", TRUE, c(2, 6, 7))
list_example
~~~
{: .language-r}



~~~
[[1]]
[1] 1

[[2]]
[1] "a"

[[3]]
[1] TRUE

[[4]]
[1] 2 6 7
~~~
{: .output}



~~~
another_list <- list(title = "Numbers", numbers = 1:10, data = TRUE )
another_list
~~~
{: .language-r}



~~~
$title
[1] "Numbers"

$numbers
 [1]  1  2  3  4  5  6  7  8  9 10

$data
[1] TRUE
~~~
{: .output}

Ahora podemos entender algo un poco sorprendente en nuestro **dataframe**; que ocurre si comparamos `str(nordic)` y `str(another_list)`:


~~~
str(nordic)
~~~
{: .language-r}



~~~
'data.frame':\t3 obs. of  3 variables:
 $ country: chr  "Denmark" "Sweden" "Norway"
 $ year   : int  2002 2002 2002
 $ lifeExp: num  77.2 80 79
~~~
{: .output}



~~~
str(another_list)
~~~
{: .language-r}



~~~
List of 3
 $ title  : chr "Numbers"
 $ numbers: int [1:10] 1 2 3 4 5 6 7 8 9 10
 $ data   : logi TRUE
~~~
{: .output}

Vemos que los resultados para estos dos objetos se ven parecidos. Esto es porque
los dataframes son listas 'tras bambalinas'. Los **dataframes** son un caso especial de lista donde cada elemento (las columnas del **dataframe**) tiene el mismo largo. 

En nuestro ejemplo `nordic`, tenemos una variable **integer**, una variable **double** y una variable **logical**. 
Como ya vimos, cada columna del **dataframe** es un vector. 


~~~
nordic$country
~~~
{: .language-r}



~~~
[1] "Denmark" "Sweden"  "Norway" 
~~~
{: .output}



~~~
nordic[, 1]
~~~
{: .language-r}



~~~
[1] "Denmark" "Sweden"  "Norway" 
~~~
{: .output}



~~~
class(nordic[, 1])
~~~
{: .language-r}



~~~
[1] "character"
~~~
{: .output}



~~~
str(nordic[, 1])
~~~
{: .language-r}



~~~
chr [1:3] "Denmark" "Sweden" "Norway"
~~~
{: .output}

Cada fila es una *observación* de diferentes variables, en sí misma un **dataframe**, y 
entonces puede estar compuesto de elementos de diferentes tipos. 


~~~
nordic[1, ]
~~~
{: .language-r}



~~~
  country year lifeExp
1 Denmark 2002    77.2
~~~
{: .output}



~~~
class(nordic[1, ])
~~~
{: .language-r}



~~~
[1] "data.frame"
~~~
{: .output}



~~~
str(nordic[1, ])
~~~
{: .language-r}



~~~
'data.frame':\t1 obs. of  3 variables:
 $ country: chr "Denmark"
 $ year   : int 2002
 $ lifeExp: num 77.2
~~~
{: .output}

> ## Desafío 4
>
> Hay varias maneras sutilmente diferentes de llamar variables, observaciones y
> elementos de los **dataframes**:
>
> - `nordic[1]`
> - `nordic[[1]]`
> - `nordic$country`
> - `nordic["country"]`
> - `nordic[1, 1]`
> - `nordic[, 1]`
> - `nordic[1, ]`
>
> Prueba estos ejemplos y explica que se devuelve en cada uno.
>
> *Sugerencia:* Usa la función `class()` para examinar que se devuelve en cada caso.
>
> > ## Solución al Desafío 4
> >
> > 
> > ~~~
> > nordic[1]
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> >   country
> > 1 Denmark
> > 2  Sweden
> > 3  Norway
> > ~~~
> > {: .output}
> >
> > Podemos pensar al **dataframe** como una lista de vectores. El corchete único `[1]`
> > devuelve la primer parte de la lista, como otra lista. En este caso es la
> > primer columna del **dataframe**.
> >
> > 
> > ~~~
> > nordic[[1]]
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> > [1] "Denmark" "Sweden"  "Norway" 
> > ~~~
> > {: .output}
> >
> > El corchete doble `[[1]]`  devuelve el contenido del ítem listado. En este caso
> >  es el contenido de la primer columna, un *vector* del tipo * factor*.
> >
> > 
> > ~~~
> > nordic$country
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> > [1] "Denmark" "Sweden"  "Norway" 
> > ~~~
> > {: .output}
> >
> > Este ejemplo use el carácter `$` para dirigirse a items por su nombre. _country_ es la
> > primer columna del **dataframe**, de nuevo un  *vector* de tipo *factor*.
> X
> > 
> > ~~~
> > nordic["country"]
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> >   country
> > 1 Denmark
> > 2  Sweden
> > 3  Norway
> > ~~~
> > {: .output}
> > Aquí usamos un corchete único `["country"]` remplazando el índice numérico
> > con el nombre de la columna. Como en el ejemplo 1, el objeto devuelto es una *lista*.
> >
> > 
> > ~~~
> > nordic[1, 1]
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> > [1] "Denmark"
> > ~~~
> > {: .output}
> >
> > Este ejemplo usa un corchete único, pero esta vez brindamos las coordenadas
> de fila y columna. El objeto devuelto es el valor en la fila 1, columna 1. El objeto
> es una  *integer* pero al ser parte de un *vector* de tipo *factor*, R
> muestra la etiqueta "Denmark" asociada con el valor del **integer**.
> >
> > 
> > ~~~
> > nordic[, 1]
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> > [1] "Denmark" "Sweden"  "Norway" 
> > ~~~
> > {: .output}
> >
> > Como los ejemplos previos, usamos el corchete único y brindamos las coordenadas de
> > fila y columna. La coordenada de fila no está especificada, R interpreta este valor
> > faltante como todos los elementos en esta *columna* *vector*.
> >
> > 
> > ~~~
> > nordic[1, ]
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> >   country year lifeExp
> > 1 Denmark 2002    77.2
> > ~~~
> > {: .output}
> >
> > Otra vez usamos el corchete único con las coordenadas de fila y columna. La coordenada de
> > columna no está especificada. El valor devuelto es una *lista* que contiene todos los
> > valores en la primer fila.
> {: .solution}
{: .challenge}

